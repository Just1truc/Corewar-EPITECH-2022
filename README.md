# Corewar
Realization of a RedCore to Bytecode compiler and a Virtual Machine interpreting and executing ``.cor`` files (Bytecode)

![Corewar Image](https://repository-images.githubusercontent.com/205827033/21423900-e07e-11e9-86dc-5655452547fa)

# Project description
The Corewar is a project at the end of the first year at Epitech. The project is divided into two parts for a group of 3 to 4 people. Each group in the promotion competes to have the best Corewar.

We have 2 bonuses, the first a viewer of the arena in the VM (interactive), then in the second bonus, a program which makes several champions compete several times in order to create a ranking of the best champions.

### Virutal Machine (VM)
In the virtual machine, champions compete in a circular 6144 bytes arena. Each champion's instruction are executed at the end of their cycle. The champions all compete in the same arena and their execution follows a scheduling.

All champions are written in RedCode (``.s`` (Assembly) compiled in Bytecode (``.cor``) thanks to the **ASM** part of the project. Only bytecode generated by the ASM part can be executed by the Virtual Machine (VM).

Each process (champions) has :

- a **Live** : value denoting whether a process is alive or not.
- a **PC** : Special register which designates the head of the champion and the command to be executed in the next cycle.
- a **Carry** : A flag indicating whether a command succeeded or not.
- 16 **Registers** : Each register is 4 bytes.

*On initialization, all registers, carry and live are initialized to 0 execpt the first register which is the player number and the PC which is the position of the first instruction of the process in the arena.*

### Rules
- The winner is the last process said to be alive (**Live**).
- Every **CYCLE_TO_DIE**, the VM checks that each process is alive (**Live**). If the Live of a process is 0 (dead), it is destroyed.
- Every **NBR_LIVE**, the **CYCLE_TO_DIE** is decremented by **CYCLE_DELTA** so that the game does not last indefinitely.

### All instructions
| **Mnemonic** | **Description** |
|:--------:|:-----------:|
| 0x01 (live) | Takes 1 parameter: 4 bytes that represent the player's number. It indicates that the player is alive. |
| 0x02 (ld) | Takes 2 parameters. It loads the value of the first parameter into the second parameter, which must be register (not a PC). **This operation modifies the Carry**. *ld 34,r3* loads the REG_SIZE bytes starting at the address *PC + 34 % IDX_MOD* into *r3*. |
| 0x03 (st) | Takes 2 parameters. It stores the first parameter's value (which is a register) into the second (whether a register or a number). *st r4,34* stores the content of *r4* at the address *PC + 34 % IDX_MOD*. *st r3,r8* copies the content of *r3* into *r8*. |
| 0x04 (add) | Takes 3 parameters. It adds the content of the first two and puts the sum into the third one (which must be a register). **This operation modifies the carry**. *add r2,r3,r5* adds the content of *r2* and *r3* and puts the result into *r5*. |
| 0x05 (sub) | Similar to *and*, but performing a substraction. |
| 0x06 (and) | Takes 3 parameters. It performs a binary **AND** between the first two parameters and stores the result into the third one (which be a register). **This operation modifies the carry**. *and r2,%0,r3* puts *r2 & 0* into *r3*. |
| 0x07 (or) | Similar to *and*, but performing a binary OR. |
| 0x08 (xor) | Similar to *and*, but performing a binary XOR (exclusive OR). |
| 0x09 (zjump) | Takes 1 parameter, which must be index. It jumps to the index if the carry is worth 1. Otherwise, it does nothing but consumes the same time. *zjump %23* puts, if carry equals 1, *PC + 23 % IDX_MOD* into the PC. |
| 0x0a (ldi) | Takes 3 parameters. The first two must be indexes, the third one must be a register. **This operation modifies the carry**. *ldi 3,%4,r1* reads **IND_SIZE** bytes from the address *PC + 3 % IDX_MOD*, adds *4* to this value. The sum is named *S*. **REG_SIZE** bytes are read from the address *PC + S % IDX_MOD* and copied into *r1*. |
| 0x0b (sti) | Takes 3 parameters. The first one must be a register. The other two can be indexes or registers. *sti r2,%4,r5* copies the content of *r2* into the address *PC + (4+5) % IDX_MOD*. |
| 0x0c (fork) | Takes 1 parameter, which must be an index. It create a new program that inherits different states from the parent. This program is executed at the address *PC + first parameter % IDX_MOD*. |
| 0x0d (lld) | Similar to *ldi* without the *% IDX_MOD*. **This operation modifies the carry**. |
| 0x0e (lldi) | Similar to *ldi* without the *% IDX_MOD*. **This operation modifies the carry**. |
| 0x0f (lfork) | Similar to *fork* without the *% IDX_MOD*. |
| 0x10 (aff) |  Takes 1 parameter, which must be a register. It displays on the standard output the character whose ASCII code is the content of the register (in base 10). A 256 modulo is applied to this ASCII code. *aff r3* displays ’*’ if *r3* contains *42*.

### ASM

The ASM part is about compiling redcode files ``.s`` into byte code files ``.cor`` and verifying if this code is correct.
You can create your *own* champions and compile them using this part of the project to use them inside the VM part.

**Check_error:**

The compiler is checked by the moulinette.
Here's a proof of quality:

![image](https://user-images.githubusercontent.com/68695857/170875173-b559b0f3-dac7-48da-9607-4a0d4d9b601d.png)

In redcode, there is some cleaning to do before parsing the code.

First, we got rid of the comments. (begin with a ``#``).

Then, each line should be splitted using the following characters : ``" ", "\t", ","``.

Once it's done, the first line should specify the name of the champion :
```asm
.name "[NAME]"
```

**Usage:**

In order to use the asm part, you have to get into the asm folder.
From the root of the repository, execute this command:
```bash
cd asm
```

In order to compile a champion (``.s``)
```shell
./asm champion_file[.s]
```
If you need help, just use the ``-h`` option:
```shell
./asm -h
```

# Install the project

```bash
git clone git@github.com:Just1truc/Corewar-EPITECH-2022.git
cd Corewar-EPITECH-2022
make
```

# Use the project

From the root of the repository:
```bash
./asm/asm [file.s]
./corewar/corewar [file.cor] [file.cor] ...
```

# Results
### ASM (Moulinette)
| **Description** | **Mark** |
|:-----------:|:----:|
| Header | 3/3 |
| Full header | 5/5 |
| Valid bytecode cases | 18/18 |
| Invalid cases | 35/35 |
| Total | 100% |

### Total (Keynote / Global)
| **Description** | **Mark** |
|:-----------------:|:----------:|
| Preliminary | 2/2 |
| Assembler | 10/10 |
| Virtual Machine | 10/10 |
| Total | 22/22 |

# Bonuses

### Corewar viewer
The first bonus is a Corewar (VM) interactive viewer.

![Menu](https://i.postimg.cc/bYxTn3Qm/Screenshot-from-2022-05-27-21-12-48.png)

---

![Choice](https://i.postimg.cc/zB1hXYP8/Screenshot-from-2022-05-27-21-13-47.png)

---

![Playing](https://i.postimg.cc/5tt4B7YL/Screenshot-from-2022-05-27-21-15-02.png)

---

![End](https://i.postimg.cc/9fNWJdZS/Screenshot-from-2022-05-27-21-15-10.png)
